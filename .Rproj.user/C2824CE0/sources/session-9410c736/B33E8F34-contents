snmf.qp <- function(x, k, W = NULL, H = NULL, init = "kmeans", maxiter = 1000, tol = 1e-6, ridge = 1e-8) {

  runtime <- proc.time()
  n <- dim(x)[1]  ;  D <- dim(x)[2]
  # Initialize W, H on simplex
  if ( init == "kmeans" ) {
    a <- kmeans(t(x), k)
    W <- matrix(nrow = n, ncol = k)
    for (i in 1:k)  W[, i] <- Rfast::rowsums( x[, a$cl == i, drop = FALSE] )
    H <- kmeans(x, k)$centers
  } else {
    if ( is.null(W) ) {
      W <- matrix( Rfast2::Runif(n * k), nrow = n, ncol = k)
      W <- W / Rfast::rowsums(W)
    }
    if ( is.null(H) ) {
      H <- matrix( Rfast2::Runif(k * D), nrow = k, ncol = D)
      H <- H / Rfast::rowsums(H)  ## FIX: rows sum to 1, not columns
    }
  }
  error <- numeric(maxiter)

  A_W <- t( rbind( rep(1, k), diag(k) ) )
  b_W <- c( 1, rep(0, k) )
  ridgek <- diag(ridge, k)

  sx2 <- sum(x^2)
  kD <- k * D
  XX <- matrix(0, kD, kD)
  ind <- matrix( 1:kD, ncol = k, byrow = TRUE )
  A <- matrix(0, kD, kD)
  for ( i in 1:k )  A[i, ind[, i]] <- 1
  A <- t( rbind( A, diag(kD) ) )
  A <- A[, -c( (k + 1): kD) ]
  bvec <- c( rep(1, k), rep(0, kD) )

  for ( it in 1:maxiter ) {
    # ----------------- W update -----------------
    G_W <- 2 * tcrossprod(H) + ridgek
    for (i in 1:n) {
      g_W <- 2 * (H %*% x[i, ])
      sol <- quadprog::solve.QP(Dmat = G_W, dvec = g_W, Amat = A_W, bvec = b_W, meq = 1)
      W[i, ] <- sol$solution
    }
    # ----------------- H update -----------------
    #H <- Compositional::scls(x, W)$be
    dvec <- as.vector( crossprod(W, x) )
    xx <- crossprod(W)
    for ( i in 1:D )  XX[ ind[i, ], ind[i, ] ] <- xx
    f <- try( quadprog::solve.QP( Dmat = XX, dvec = dvec, Amat = A, bvec = bvec,
                                meq = k ), silent = TRUE )
    if ( identical(class(f), "try-error") ) {
      f <- quadprog::solve.QP( Dmat = Matrix::nearPD(XX)$mat, dvec = dvec, Amat = A, bvec = bvec, meq = k )
    }
    H <- matrix( abs(f$solution), ncol = D)
    err <- sx2 + 2 * f$value
    error[it] <- err
    if ( it > 1 && abs(error[it - 1] - err) < tol ) {
      break
    }
  }

  runtime <- proc.time() - runtime

  list(W = abs(W), H = abs(H), Z = W %*% H, obj = error[it], iters = it, runtime = runtime)
}



# snmf.qp_old <- function(x, k, maxiter = 10000, tol = 1e-6, ridge = 1e-6) {
  # n <- dim(x)[1]  ;  D <- dim(x)[2]
  # # Initialize W, H on simplex
  # W <- matrix( Rfast2::Runif(n * k), nrow = n, ncol = k)
  # W <- W / Rfast::rowsums(W)
  # H <- matrix( Rfast2::Runif(k * D), nrow = k, ncol = D)
  # H <- H / Rfast::rowsums(H)  ## FIX: rows sum to 1, not columns
  # error <- numeric(maxiter)
  # A_W <- rbind( rep(1, k), diag(k) )
  # b_W <- c( 1, rep(0, k) )
  # ridgek <- diag(ridge, k)

  # for ( it in 1:maxiter ) {
    # # ----------------- W update -----------------
    # G_W <- 2 * tcrossprod(H) + ridgek
    # for (i in 1:n) {
      # g_W <- 2 * (H %*% x[i, ])
      # sol <- quadprog::solve.QP(Dmat = G_W, dvec = g_W, Amat = t(A_W), bvec = b_W, meq = 1)
      # W[i, ] <- sol$solution
    # }
    # # ----------------- H update -----------------
    # WH <- W %*% H
    # A_H <- rbind(rep(1, D), diag(D))
    # b_H <- c(1, rep(0, D))

    # for ( j in 1:k ) {
      # # Residual without row j's contribution
      # WH_minus_j <- WH - W[, j] %*% H[j, , drop = FALSE]
      # Rj <- x - WH_minus_j
      # # Weighted least squares with weights W[,j]^2
      # w3 <- W[, j]^3    ;  w4 <- W[, j]^4
      # # Linear term: 2 * sum_i W[i,j]^3 * Rj[i,d] for each d
      # g_H <- 2 * Rfast::colsums(w3 * Rj)
      # # Quadratic term: 2 * (sum_i W[i,j]^4) * I_D
      # G_H <- 2 * sum(w4) * diag(D) + diag(ridge, D)
      # sol <- quadprog::solve.QP(Dmat = G_H, dvec = g_H, Amat = t(A_H), bvec = b_H, meq = 1)
      # H[j, ] <- sol$solution
    # }
    # # ----------------- Error -----------------
    # err <- sum( (x - W %*% H)^2 )
    # error[it] <- err
    # if ( it > 1 && abs(error[it - 1] - err) < tol ) {
      # break
    # }
  # }

  # list(W = W, H = H, Z = W %*% H, obj = error[it], iters = it)
# }
