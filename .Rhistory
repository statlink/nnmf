source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
ternary(mod$W, colour = group)
mod$obj
mod$@
mod$W
maxiter = 1000
tol = 1e-6
ridge = 1e-8
mod$H
n <- dim(x)[1]
D <- dim(x)[2]
# Initialize W and H randomly and normalize to simplex
W <- matrix(Rfast2::Runif(n * k), nrow = n, ncol = k)
k=3
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
ternary(mod$W, colour = group)
n <- dim(x)[1]
D <- dim(x)[2]
# Initialize W and H randomly and normalize to simplex
W <- matrix(Rfast2::Runif(n * k), nrow = n, ncol = k)
W <- W / Rfast::rowsums(W)
H <- matrix(Rfast2::Runif(k * D), nrow = k, ncol = D)
H <- H / Rfast::rowsums(H)
prev.obj <- NULL
# Setup for H update (each column on simplex)
Aeq_H   <- rep(1, k)
Aineq_H <- diag(k)
Amat_H  <- cbind(Aeq_H, Aineq_H)
bvec_H  <- c(1, rep(0, k))
meq     <- 1
ridgeK <- ridge * Aineq_H
# Setup for W update (each row on simplex)
Aeq_W   <- rep(1, k)
Aineq_W <- diag(k)
Amat_W  <- cbind(Aeq_W, Aineq_W)
bvec_W  <- c(1, rep(0, k))
## Update H: each COLUMN on simplex
WtW <- crossprod(W)           # k x k
WtX <- crossprod(W, x)        # k x D
DmatH <- 2 * WtW + ridgeK
d=1
dvec <- 2 * WtX[, d]        # gradient for column d
sol <- try(
solve.QP(Dmat = DmatH, dvec = dvec, Amat = Amat_H,
bvec = bvec_H, meq = meq)$solution,
silent = TRUE
)
sol
dvec <- 2 * WtX[, d]        # gradient for column d
sol <- try(
quadprog::solve.QP(Dmat = DmatH, dvec = dvec, Amat = Amat_H,
bvec = bvec_H, meq = meq)$solution,
silent = TRUE
)
sol
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
ternary(mod$W, colour = group)
mod$obj
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
rowSums(mod$H)
colSums(mod$H)
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$W
mod$H
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
rowsums(mod$W)
rowSums(mod$W)
rowSums(mod$Z)
source("~/GitHub/CompositionalDR/R/saa.qp.R")
n <- dim(x)[1]
D <- dim(x)[2]
# Initialize W and H randomly and normalize to simplex
W <- matrix(Rfast2::Runif(n * k), nrow = n, ncol = k)
k=3
x
maxiter
maxiter=100
tol
tol=1e-6
ridge=1e-8
n <- dim(x)[1]
D <- dim(x)[2]
# Initialize W and H randomly and normalize to simplex
W <- matrix(Rfast2::Runif(n * k), nrow = n, ncol = k)
W <- W / Rfast::rowsums(W)
H <- matrix(Rfast2::Runif(k * D), nrow = k, ncol = D)
H <- H / Rfast::rowsums(H)
prev.obj <- NULL
ridgeD <- ridge * diag(D)
ridgeK <- ridge * diag(k)
# Setup for H update (each row on simplex in D dimensions)
Aeq_H   <- rep(1, D)
Aineq_H <- diag(D)
Amat_H  <- cbind(Aeq_H, Aineq_H)
bvec_H  <- c(1, rep(0, D))
meq     <- 1
# Setup for W update (each row on simplex in k dimensions)
Aeq_W   <- rep(1, k)
Aineq_W <- diag(k)
Amat_W  <- cbind(Aeq_W, Aineq_W)
bvec_W  <- c(1, rep(0, k))
j=1
w_j <- W[, j]                    # column j of W (n-vector)
norm_sq <- sum(w_j^2)
DmatH <- 2 * norm_sq * diag(D) + ridgeD
dvec <- 2 * drop(crossprod(w_j, x))  # w_j^T X (D-vector)
sol <- try(
solve.QP(Dmat = DmatH, dvec = dvec, Amat = Amat_H,
bvec = bvec_H, meq = meq)$solution,
silent = TRUE
)
sol
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$H
mod$W
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$W
mod$H
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$W
mod$H
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$W
mod$H
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
library(quadprog)
# simplex constraints for solve.QP
make_simplex_constraints <- function(d) {
A <- rbind(rep(1, d), diag(d))
b <- c(1, rep(0, d))
list(A = A, b = b)
}
# Solve simplex-constrained least squares: min_x ||y - xM||^2
qp_ls_simplex <- function(y, M, ridge = 1e-8) {
G <- 2 * (M %*% t(M)) + diag(ridge, nrow(M))
g <- 2 * (M %*% y)
d <- nrow(M)
C <- make_simplex_constraints(d)
sol <- solve.QP(
Dmat = G,
dvec = g,
Amat = t(C$A),
bvec = C$b,
meq = 1
)
sol$solution
}
# -------------------------------------------------------------
# Main ALS with correct H-update (QP)
# -------------------------------------------------------------
saa.qp <- function(X, r, maxiter = 50, tol = 1e-6, ridge = 1e-8, verbose = TRUE) {
m <- nrow(X); n <- ncol(X)
# initialize W,H on simplex
W <- matrix(1/r, m, r)
H <- matrix(1/n, r, n)
errors <- numeric(maxiter)
for (it in 1:maxiter) {
# ----------------- W update -----------------
for (i in 1:m) {
y <- X[i, ]
M <- H
W[i, ] <- qp_ls_simplex(y, M, ridge)
}
# ----------------- H update -----------------
WH <- W %*% H
for (k in 1:r) {
WH_minus_k <- WH - W[, k] %*% H[k, , drop = FALSE]
Rk <- X - WH_minus_k
w2  <- W[, k]^2      # weights
w3  <- W[, k]^3
w4  <- W[, k]^4
# linear term
g <- 2 * colSums( w3 * Rk )
# quadratic term (scalar * identity matrix)
G <- 2 * sum(w4) * diag(n)
C <- make_simplex_constraints(n)
sol <- solve.QP(
Dmat = G,
dvec = g,
Amat = t(C$A),
bvec = C$b,
meq = 1
)
H[k, ] <- sol$solution
}
# ----------------- error -----------------
err <- sqrt(sum((X - W %*% H)^2))
errors[it] <- err
if (verbose) cat(sprintf("iter %3d   error %.8f\n", it, err))
if (it > 1 && abs(errors[it - 1] - err) < tol)
break
}
list(W = W, H = H, errors = errors)
}
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$errors
mod$W
rowSums(mod$W)
rowSums(mod$H)
mod$errors
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3, maxiter=100)
group <- as.numeric(iris[, 5])
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$errors
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$errors
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
group <- as.numeric(iris[, 5])
mod$obj
mod$W
ternary(mod$W, colour = group)
ternary(mod$W, colour = group)
ternary(mod$W, colour = group)
ternary(mod$W, colour = group)
library(Compositional)
ternary(mod$W, colour = group)
library(Compositional)
source("~/.active-rstudio-document")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
source("~/.active-rstudio-document")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
tol
maxiter
maxiter=10000
m <- nrow(X)
X=x
m <- nrow(X)
n <- ncol(X)
# Initialize W,H on simplex
W <- matrix(1/r, m, r)
r=3
m <- nrow(X)
n <- ncol(X)
# Initialize W,H on simplex
W <- matrix(1/r, m, r)
H <- matrix(1/r, r, n)
errors <- numeric(maxiter)
it=1
for (i in 1:m) {
y <- X[i, ]
M <- H
W[i, ] <- qp_ls_simplex(y, M, ridge)
}
# ----------------- H update -----------------
WH <- W %*% H
for (k in 1:r) {
# Residual without row k's contribution
WH_minus_k <- WH - W[, k] %*% H[k, , drop = FALSE]
Rk <- X - WH_minus_k
# Weighted least squares with weights W[,k]^2
w2 <- W[, k]^2      # weights
w3 <- W[, k]^3
w4 <- W[, k]^4
# Linear term: 2 * sum_i W[i,k]^3 * Rk[i,j] for each j
g <- 2 * colSums(w3 * Rk)
# Quadratic term: 2 * (sum_i W[i,k]^4) * I_n
G <- 2 * sum(w4) * diag(n) + diag(ridge, n)
C <- make_simplex_constraints(n)
sol <- solve.QP(
Dmat = G,
dvec = g,
Amat = t(C$A),
bvec = C$b,
meq = 1
)
H[k, ] <- sol$solution
}
err <- sum( (X - W %*% H)^2 )
err
errors[it] <- err
errors
errors[1]
errors[2]
it
source("~/.active-rstudio-document")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$obj
source("~/GitHub/CompositionalDR/R/saa.md.R")
mod=saa.md(x,3)
mod$obj
source("~/GitHub/CompositionalDR/R/saa.md.R")
mod$obj
mod=saa.md(x,3)
mod$obj
source("~/.active-rstudio-document")
mod=saa.qp(x,3)
mod$obj
rowsums(mod$W)
rowSums(mod$W)
rowSums(mod$H)
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$obj
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$errors
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$obj
(H %*% t(H))
tcrossprod(H)
mod$iters
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$obj
mod$iters
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$obj
mod$iters
source("~/GitHub/CompositionalDR/R/saa.qp.R")
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
mod$obj
source("~/GitHub/CompositionalDR/R/saakl.eg.R")
mod=saakl.eg(x,3)
mod$obj
ternary(mod$W,colour=group)
x <- as.matrix(iris[, 1:4])
x <- x / rowSums(x)
mod <- saa.qp(x, 3)
ternary(mod$W,colour=group)
library(CompositionalDR)
